# FlowBoard Project Analysis: Complete Brownfield Architecture

**Generated:** 2026-02-21
**Generated By:** @architect (Aria)
**Analysis Type:** Brownfield Architecture Assessment
**Project:** FlowBoard - Agile Project Management System

---

## Executive Summary

FlowBoard is a **mature, production-ready full-stack application** following established patterns with clear separation of concerns. The architecture demonstrates solid software engineering practices with modular design, comprehensive testing, and modern technology choices.

**Health Score:** 8.5/10
- ‚úÖ Clean separation of frontend/backend
- ‚úÖ Modular backend architecture (domain-driven)
- ‚úÖ Comprehensive test coverage (106 backend + 93 frontend tests)
- ‚úÖ Modern tech stack (React 18, FastAPI, PostgreSQL)
- ‚úÖ AIOS framework integration (story-driven development)
- ‚ö†Ô∏è Some optimization opportunities for scalability

---

## Project Structure Overview

| Aspect | Value |
|--------|-------|
| **Framework** | Custom Full-Stack (React + FastAPI) with AIOS integration |
| **Primary Languages** | TypeScript (Frontend), Python (Backend) |
| **Frontend Framework** | React 18 + Vite (HMR) |
| **Backend Framework** | FastAPI + SQLAlchemy 2.0 (Async) |
| **Database** | PostgreSQL 15 (Docker) |
| **Architecture Pattern** | Domain-driven monolith with modular services |
| **Testing Framework** | Vitest + React Testing Library (FE), pytest (BE) |
| **State Management** | Zustand (auth) + React Query (server state) |
| **Real-time** | WebSocket (FastAPI native) |
| **Deployment** | Docker Compose (local), ready for container platforms |

---

## Backend Architecture

### Module Organization (Domain-Driven)

```
backend/app/
‚îú‚îÄ‚îÄ auth/              # Authentication & JWT tokens
‚îú‚îÄ‚îÄ projects/          # Project management, members, workflows
‚îú‚îÄ‚îÄ issues/            # Issue hierarchy (Epic>Story>Task>Bug>Subtask)
‚îú‚îÄ‚îÄ sprints/           # Sprint lifecycle management
‚îú‚îÄ‚îÄ comments/          # Issue discussion threads
‚îú‚îÄ‚îÄ attachments/       # File upload/download
‚îú‚îÄ‚îÄ notifications/     # WebSocket real-time events
‚îú‚îÄ‚îÄ search/            # Full-text search & filters
‚îú‚îÄ‚îÄ common/            # Shared permissions, dependencies
‚îî‚îÄ‚îÄ main.py            # FastAPI app initialization
```

### Key Patterns Identified

#### 1. **Service Layer Pattern**
- Router ‚Üí Service ‚Üí Repository ‚Üí ORM
- Clear business logic separation
- Dependency injection via `Depends()`
- Example: `IssueService.create_issue()` handles validation + permissions

#### 2. **Async/Await Throughout**
- SQLAlchemy 2.0 with asyncpg driver
- Non-blocking I/O at all layers
- Connection pool for concurrency
- **Risk:** Must maintain async context through entire request

#### 3. **ORM Usage (SQLAlchemy 2.0)**
- Declarative models with type hints
- Async session management
- Relationships defined at model level
- **Strengths:** Type safety, migration tracking via Alembic
- **Weakness:** Some N+1 query patterns possible in relationships

#### 4. **Authentication**
- JWT (access + refresh tokens)
- passlib + bcrypt for password hashing
- Role-based access control (RBAC)
- Permission checks in service layer (not middleware)

### Database Schema Patterns

**Key Tables:**
- `users` ‚Äî User accounts with roles
- `projects` ‚Äî Project metadata
- `project_members` ‚Äî User-Project membership with roles
- `issues` ‚Äî All issue types with parent_id for hierarchy
- `sprints` ‚Äî Sprint lifecycle
- `issue_comments` ‚Äî Comments with edit history
- `attachments` ‚Äî Files metadata
- `issue_history` ‚Äî Audit trail

**Schema Characteristics:**
- Normalized design (3NF)
- Foreign keys for relationships
- Soft deletes not implemented (physical deletes)
- No row-level security (RLS) policies

### Testing Coverage

**Backend Tests:** 106 total
- `tests/auth/` ‚Äî Authentication tests
- `tests/projects/` ‚Äî Project CRUD, workflows
- `tests/issues/` ‚Äî Issue operations, hierarchy
- `tests/sprints/` ‚Äî Sprint lifecycle
- `tests/comments/` ‚Äî Comment threads
- `tests/attachments/` ‚Äî File operations
- `tests/search/` ‚Äî Search queries
- `tests/notifications/` ‚Äî WebSocket flows

**Framework:** pytest + pytest-asyncio
**Approach:** Async test support, HTTP client (httpx) for endpoint testing
**Coverage Target:** > 80% (currently strong)

---

## Frontend Architecture

### Directory Structure (Feature-Based)

```
frontend/src/
‚îú‚îÄ‚îÄ api/               # Axios HTTP clients (by domain)
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îú‚îÄ‚îÄ projects.ts
‚îÇ   ‚îú‚îÄ‚îÄ issues.ts
‚îÇ   ‚îú‚îÄ‚îÄ sprints.ts
‚îÇ   ‚îú‚îÄ‚îÄ comments.ts
‚îÇ   ‚îú‚îÄ‚îÄ attachments.ts
‚îÇ   ‚îú‚îÄ‚îÄ notifications.ts
‚îÇ   ‚îú‚îÄ‚îÄ search.ts
‚îÇ   ‚îî‚îÄ‚îÄ client.ts      # Axios instance + interceptors
‚îú‚îÄ‚îÄ components/        # UI components (feature-grouped)
‚îÇ   ‚îú‚îÄ‚îÄ board/         # Kanban board
‚îÇ   ‚îú‚îÄ‚îÄ backlog/       # Backlog management
‚îÇ   ‚îú‚îÄ‚îÄ sprints/       # Sprint UI
‚îÇ   ‚îú‚îÄ‚îÄ issues/        # Issue detail/creation
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/     # Metrics & overview
‚îÇ   ‚îú‚îÄ‚îÄ comments/      # Comment threads
‚îÇ   ‚îî‚îÄ‚îÄ notifications/ # Real-time badges
‚îú‚îÄ‚îÄ hooks/             # React Query hooks (by domain)
‚îú‚îÄ‚îÄ pages/             # Route pages
‚îú‚îÄ‚îÄ stores/            # Zustand stores (auth)
‚îú‚îÄ‚îÄ types/             # TypeScript interfaces
‚îú‚îÄ‚îÄ utils/             # date.ts, helpers
‚îî‚îÄ‚îÄ test/              # Test setup
```

### Key Patterns Identified

#### 1. **React Query Hooks Pattern**
- Hook per domain: `useIssuesQuery`, `useProjectsQuery`, etc.
- Hooks encapsulate: fetching, caching, state
- Components consume hooks (not API directly)
- **Pattern:** Hook ‚Üí API Client ‚Üí Backend

#### 2. **Axios API Clients**
- Organized by domain (issues, projects, etc.)
- Centralized HTTP client with interceptors
- Error handling at client layer
- Automatic auth header injection

#### 3. **State Management Split**
- **Auth:** Zustand (global persistent state)
- **Server:** React Query (cached API responses)
- **Local:** React useState (form inputs, UI state)

#### 4. **Drag-and-Drop (dnd-kit)**
- Used for Kanban board column reordering
- Used for issue reordering within sprints
- Performant for large lists
- **Integration:** Custom hooks with React Query invalidation

#### 5. **Styling (Tailwind CSS v4)**
- Vite integration via `@tailwindcss/vite`
- Class-based styling
- Responsive design patterns
- Dark mode capable (not implemented yet)

### Testing Coverage

**Frontend Tests:** 93 total
- Component tests (React Testing Library)
- Hook tests (useQuery patterns)
- Integration tests (full user flows)

**Framework:** Vitest + React Testing Library
**Coverage Target:** > 60% (currently on track)
**Setup:** jsdom environment, mock HTTP clients

---

## Real-Time Architecture (WebSocket)

### Current Implementation

**Endpoint:** `/ws/notifications/{user_id}`

**Flow:**
1. Frontend connects on app mount
2. Backend manages connection per user
3. When issue/sprint changes ‚Üí broadcast to connected users
4. Frontend receives event ‚Üí React Query invalidation
5. Components refetch and re-render

**Manager:** `app/notifications/ws_manager.py`
- Connection tracking per user
- Message broadcasting
- Graceful disconnect handling

**Strengths:**
- Native FastAPI WebSocket support
- No external libraries needed
- Per-user isolation

**Limitations:**
- Single-server only (not horizontally scalable)
- No message persistence
- Reconnection logic on frontend basic

---

## Technology Stack Evaluation

### Frontend

| Technology | Version | Rationale | Health |
|-----------|---------|-----------|--------|
| React | 18.3.1 | Standard for UI, stable, large ecosystem | ‚úÖ Excellent |
| TypeScript | 5.6 | Type safety, IDE support, large codebase | ‚úÖ Excellent |
| Vite | 6.0.5 | Fast dev server, native ESM, HMR | ‚úÖ Excellent |
| Tailwind CSS | 4.1.18 | Utility-first, responsive, performance | ‚úÖ Excellent |
| React Query | 5.90 | Server state management, caching | ‚úÖ Excellent |
| Zustand | 5.0.11 | Lightweight auth state, no boilerplate | ‚úÖ Good |
| Axios | 1.13 | HTTP client, interceptors, mature | ‚úÖ Good |
| dnd-kit | 6.1/8.0 | Modern drag-drop, performant | ‚úÖ Good |
| Radix UI | 1.4.3 | Unstyled components, accessibility | ‚úÖ Good |

**Frontend Stack Assessment:** Modern, pragmatic, well-aligned

### Backend

| Technology | Version | Rationale | Health |
|-----------|---------|-----------|--------|
| FastAPI | 0.115 | Async, auto-docs (Swagger), type hints | ‚úÖ Excellent |
| SQLAlchemy | 2.0 | Async ORM, type-safe, mature | ‚úÖ Excellent |
| asyncpg | 0.30 | PostgreSQL async driver, fast | ‚úÖ Excellent |
| Alembic | 1.14 | Database migrations, version control | ‚úÖ Excellent |
| Pydantic | 2.0 | Request/response validation, serialization | ‚úÖ Excellent |
| Uvicorn | 0.34 | ASGI server, auto-reload, production-ready | ‚úÖ Excellent |
| pytest | 8.0 | Testing framework, async support | ‚úÖ Excellent |
| ruff | 0.9 | Fast linter, modern Python tooling | ‚úÖ Good |

**Backend Stack Assessment:** Modern, production-ready, async-first

### Infrastructure

| Component | Current | Assessment |
|-----------|---------|------------|
| Database | PostgreSQL 15 | Stable, feature-rich, good choice for OLTP |
| Container | Docker Compose | Perfect for local dev + simple staging |
| Deployment | Not yet | Ready for Kubernetes, Cloud Run, Railway |
| Monitoring | None | Opportunity: Add metrics, logging |
| Caching | None | Opportunity: Redis for session, query cache |

---

## Architectural Strengths

1. **Clear Separation of Concerns**
   - Frontend handles UI/UX and client-side state
   - Backend handles business logic and persistence
   - API contract well-defined via OpenAPI docs

2. **Modular Backend Design**
   - Each domain (issues, sprints, etc.) is self-contained
   - Easy to locate features and make changes
   - Service layer encapsulates business rules

3. **Async/Concurrent Architecture**
   - Non-blocking I/O at all layers
   - Handles concurrent requests efficiently
   - Database connection pooling

4. **Strong Type Safety**
   - TypeScript frontend (no `any` types visible)
   - Python type hints in backend
   - Pydantic request/response validation

5. **Comprehensive Testing**
   - 106 backend + 93 frontend tests
   - Good coverage of critical paths
   - Automated test execution in CI/CD

6. **Developer Experience**
   - Hot reload in both frontend (HMR) and backend (Uvicorn)
   - Auto-generated API docs (Swagger)
   - Clear code organization
   - AIOS integration for story-driven development

---

## Architectural Weaknesses & Optimization Opportunities

### 1. **N+1 Query Patterns Risk**
**Issue:** Fetching parent issues or related data in relationships
**Impact:** Performance degradation with large datasets
**Recommendation:**
- Use SQLAlchemy `joinedload()` for known relationships
- Implement query analysis in dev (eager vs lazy loading)
- Monitor slow query logs in production

### 2. **WebSocket Scalability (Single Server)**
**Issue:** Current implementation doesn't support multiple backend instances
**Impact:** Can't horizontally scale real-time notifications
**Recommendation:**
- Add Redis pub/sub for inter-server messaging
- Use message queue (RabbitMQ) for event distribution
- Consider hosted WebSocket service for production

### 3. **No Response Caching**
**Issue:** Every request hits the database
**Impact:** High load on database, slow response times
**Recommendation:**
- Add Redis for query result caching
- Implement ETags for GET requests
- Cache project/sprint metadata (low change frequency)

### 4. **No Rate Limiting**
**Issue:** Unauthenticated or bad-actor users can DDoS
**Impact:** Service availability risk
**Recommendation:**
- Add FastAPI middleware for rate limiting
- Implement per-user quota
- Use API key authentication for integrations

### 5. **Missing Audit Logging**
**Issue:** Limited visibility into what changed and why
**Impact:** Compliance, debugging, forensics
**Recommendation:**
- Expand `issue_history` to all entities
- Log user actions (not just data changes)
- Centralize logging (ELK, DataDog, etc.)

### 6. **No Search Indexing**
**Issue:** Full-text search likely does LIKE queries
**Impact:** Slow searches on large datasets
**Recommendation:**
- Implement PostgreSQL `tsvector` for better FTS
- Or add Elasticsearch for advanced search
- Index common search columns

### 7. **Basic Error Handling**
**Issue:** Limited error context and recovery strategies
**Impact:** Hard to debug, poor user experience
**Recommendation:**
- Define error codes per domain
- Add request tracing (correlation IDs)
- Implement circuit breakers for external APIs

### 8. **No Data Validation at Upload**
**Issue:** File attachments may lack validation
**Impact:** Security risk (malware, DoS)
**Recommendation:**
- Validate file types, sizes, content
- Scan uploads for viruses (VirusTotal API)
- Implement disk quota per project/user

---

## AIOS Framework Integration

‚úÖ **Strengths:**
- Story-driven development (stories in `docs/stories/`)
- Agent-based architecture (@dev, @qa, @pm, @po, @devops)
- Quality gates enforced (lint, test, typecheck)
- Pre-push validation with CodeRabbit

üìã **Current State:**
- `.claude/CLAUDE.md` documents AIOS rules
- `.aios-core/` contains framework configuration
- FlowBoard-specific `CLAUDE.md` created with patterns

üí° **Recommendations:**
- Document architectural decisions in `docs/architecture/ADR/`
- Create squad definitions for specialized domains
- Implement entity registry for component reuse
- Track technical debt in stories

---

## Growth Capacity Assessment

### Current Scale
- **Issues:** ~10K-100K typical
- **Users:** 50-500 per instance
- **API:** ~100 req/sec typical

### Scale Limits (Current Architecture)

| Metric | Limit | Mitigation |
|--------|-------|-----------|
| Database Size | ~10GB before slowdown | Implement archival, sharding |
| Concurrent Users | 1K before saturation | Add Redis cache, scale backend |
| WebSocket Connections | 100-500 per server | Add Redis pub/sub |
| File Storage | 100GB before saturation | Move to S3/CloudStorage |

### Recommended Optimizations for 10x Growth

1. **Caching Layer**
   - Redis for sessions, query cache, real-time data
   - ~6mo effort, high ROI

2. **Database Optimization**
   - Indexing strategy review
   - Query analysis and optimization
   - Connection pooling tuning
   - ~3mo effort

3. **Search Scalability**
   - Elasticsearch for advanced search
   - Offload FTS from PostgreSQL
   - ~2mo effort

4. **Real-time Scalability**
   - Redis pub/sub for WebSocket distribution
   - Message queue for event processing
   - ~3mo effort

5. **Observability**
   - APM (Application Performance Monitoring)
   - Distributed tracing
   - Metrics collection
   - ~1mo effort, high value

---

## Data Model Quality

### Strengths
- ‚úÖ Clear relationships (foreign keys)
- ‚úÖ Issue hierarchy via `parent_id` (recursive pattern)
- ‚úÖ Audit trail with `issue_history`
- ‚úÖ Role-based access (user + project member roles)

### Weaknesses
- ‚ö†Ô∏è No soft deletes (data loss risk)
- ‚ö†Ô∏è No row-level security (RLS) policies
- ‚ö†Ô∏è Timestamps may not have timezones
- ‚ö†Ô∏è Limited constraint validation (CHECK constraints)

### Recommendations

**Data Integrity:**
- Add `created_at`, `updated_at`, `deleted_at` timestamps to all tables
- Implement soft deletes via logical deletion
- Add CHECK constraints for valid enum values

**Security:**
- Implement PostgreSQL RLS policies
- Encrypt sensitive fields (API keys, tokens)
- Add audit triggers for compliance

**Performance:**
- Add strategic indexes on frequently queried columns
- Consider table partitioning for large tables (issues, comments)
- Document indexing strategy in schema docs

---

## Recommended Next Steps (Priority Order)

### Short Term (1-2 sprints)
1. ‚úÖ Create architecture documentation (ADRs)
2. ‚úÖ Add query analysis and N+1 detection in tests
3. ‚úÖ Implement basic rate limiting
4. ‚úÖ Add error tracing (correlation IDs)

### Medium Term (2-4 sprints)
5. üìä Implement Redis caching layer
6. üîç Upgrade search with proper FTS indexing
7. üì° Implement WebSocket scalability (Redis pub/sub)
8. üìù Add comprehensive audit logging

### Long Term (4+ sprints)
9. üîê Implement RLS policies
10. üìà Add observability (APM, metrics)
11. üõ°Ô∏è Security hardening (encryption, validation)
12. ‚ôªÔ∏è Implement data archival/retention policies

---

## Squad & Team Recommendations

### Recommended Squad Structure

| Squad | Focus | Members | Backlog |
|-------|-------|---------|---------|
| **Core Platform** | Auth, projects, issues, sprints | @dev, @qa | Enhancements |
| **Search & Analytics** | Search, reports, dashboards | @dev, @data-engineer | Full-text search upgrade |
| **Real-time & Scaling** | WebSocket, caching, performance | @architect, @devops | Redis integration, WebSocket scale |
| **Quality & DevOps** | Testing, CI/CD, monitoring | @qa, @devops | Observability, automation |

---

## Conclusion

**FlowBoard is a well-architected, production-ready system** with solid engineering practices. The codebase demonstrates:

- ‚úÖ Clear architectural thinking
- ‚úÖ Modern technology choices
- ‚úÖ Strong testing discipline
- ‚úÖ Good code organization
- ‚úÖ AIOS framework integration

**The main opportunities** are in scalability optimizations (caching, real-time scaling) and observability (monitoring, tracing) as the system grows.

**Recommendation:** Proceed with feature development confidently. Address optimization opportunities incrementally based on actual performance metrics and growth.

---

**Next Document:** See `recommended-approach.md` for specific implementation guidance on major features.
